# name: test/sql/pac_bitslice_compiler_fk.test
# description: Test GROUP BY aggregation on a non-privacy-unit table that references a PU table via PK-FK
# group: [sql]

require pac

# Create PU table (primary key) and a non-PU table referencing it via FK
statement ok
CREATE TABLE bitslice_fk_pu(
    id INTEGER PRIMARY KEY,
    meta INTEGER
);

statement ok
CREATE TABLE bitslice_fk_child(
    id INTEGER PRIMARY KEY,
    pu_id INTEGER REFERENCES bitslice_fk_pu(id),
    grp INTEGER,
    val INTEGER
);

# Insert 25 rows into PU (ids 0..4 repeated relations)
statement ok
INSERT INTO bitslice_fk_pu
SELECT i AS id, (i % 7) AS meta
FROM range(5) t(i);

statement ok
INSERT INTO bitslice_fk_child
SELECT i AS id, (i % 5) AS pu_id, (i % 5) AS grp, (i % 10) AS val
FROM range(25) t(i);

# Create a leaf table that references the child (this will be the scanned table t1)
statement ok
CREATE TABLE bitslice_fk_leaf(
    id INTEGER PRIMARY KEY,
    child_id INTEGER REFERENCES bitslice_fk_child(id),
    grp INTEGER,
    val INTEGER
);

statement ok
INSERT INTO bitslice_fk_leaf
SELECT i AS id, i AS child_id, (i % 5) AS grp, (i % 10) AS val
FROM range(25) t(i);

statement ok
pRAGMA add_pac_privacy_unit('bitslice_fk_pu');

statement ok
set pac_seed = 42;

# Single GROUP BY query on the non-PU table (grp, SUM(val))
query II
SELECT grp, SUM(val)
FROM bitslice_fk_child
GROUP BY grp
ORDER BY grp
----
0	0
1	15
2	40
3	25
4	60

# Single GROUP BY with multiple aggregates (SUM, COUNT, AVG) on FK child table
query IIII
SELECT grp, SUM(val), COUNT(val), AVG(val)::DECIMAL(5, 2)
FROM bitslice_fk_child
GROUP BY grp
ORDER BY grp
----
0	0	0	0.00
1	15	5	3.00
2	40	0	8.00
3	25	0	5.00
4	60	5	12.00

# Testing with AVG
query II
SELECT grp, AVG(val)::DECIMAL(5, 2)
FROM bitslice_fk_child
GROUP BY grp
ORDER BY grp
----
0	0.00
1	3.00
2	8.00
3	5.00
4	12.00

# 2-join aggregation: t1 (leaf) -> t2 (child) -> t3 (pu). t1 is scanned and t3 is the PU
query II
SELECT l.grp, SUM(l.val)
FROM bitslice_fk_leaf l
GROUP BY l.grp
ORDER BY l.grp
----
0	0
1	15
2	40
3	25
4	60

# Additional tests: deeper chains and joins between two non-PU tables linked to the same PU

# Create a deep chain (child -> deep1 -> deep2 -> deepleaf). We will scan deepleaf (PU not directly scanned)
statement ok
CREATE TABLE bitslice_deep1(
    id INTEGER PRIMARY KEY,
    child_id INTEGER REFERENCES bitslice_fk_child(id)
);

statement ok
CREATE TABLE bitslice_deep2(
    id INTEGER PRIMARY KEY,
    d1_id INTEGER REFERENCES bitslice_deep1(id)
);

statement ok
CREATE TABLE bitslice_deepleaf(
    id INTEGER PRIMARY KEY,
    d2_id INTEGER REFERENCES bitslice_deep2(id),
    grp INTEGER,
    val INTEGER
);

# Populate deep chain (align ids to map to child ids modulo 5)
statement ok
INSERT INTO bitslice_deep1
SELECT i AS id, (i % 5) AS child_id
FROM range(5) t(i);

statement ok
INSERT INTO bitslice_deep2
SELECT i AS id, (i % 5) AS d1_id
FROM range(5) t(i);

# deepleaf: 25 rows mapping to deep2 ids (0..4)
statement ok
INSERT INTO bitslice_deepleaf
SELECT i AS id, (i % 5) AS d2_id, (i % 5) AS grp, (i % 10) AS val
FROM range(25) t(i);

# Create a second non-PU table that references the same PU (bitslice_fk_side)
statement ok
CREATE TABLE bitslice_fk_side(
    id INTEGER PRIMARY KEY,
    pu_id INTEGER REFERENCES bitslice_fk_pu(id),
    grp2 INTEGER,
    val2 INTEGER
);

statement ok
INSERT INTO bitslice_fk_side
SELECT i AS id, (i % 5) AS pu_id, (i % 5) AS grp2, (i % 10) AS val2
FROM range(25) t(i);

# Aggregation over deepleaf (SUM)
query II
SELECT grp, SUM(val)
FROM bitslice_deepleaf
GROUP BY grp
ORDER BY grp
----
0	0
1	15
2	40
3	25
4	60

# AVG over deepleaf
query II
SELECT grp, AVG(val)::DECIMAL(5,2)
FROM bitslice_deepleaf
GROUP BY grp
ORDER BY grp
----
0	0.00
1	3.00
2	8.00
3	5.00
4	12.00

# MIN over deepleaf
query II
SELECT grp, MIN(val)
FROM bitslice_deepleaf
GROUP BY grp
ORDER BY grp
----
0	0
1	0
2	2
3	1
4	4

# Test with INNER JOIN (similar to LEFT JOIN case)
query II
SELECT grp, MIN(val)
FROM bitslice_deepleaf d1 INNER JOIN bitslice_deep2 d2 ON d1.d2_id = d2.id
GROUP BY grp
ORDER BY grp
----
0	0
1	0
2	2
3	1
4	4

# Test with LEFT JOIN
query II
SELECT grp, MIN(val)
FROM bitslice_deepleaf d1 LEFT JOIN bitslice_deep2 d2 ON d1.d2_id = d2.id
GROUP BY grp
ORDER BY grp
----
0	0
1	0
2	2
3	1
4	4

# Test with multiple INNER JOINs in the FK chain (deepleaf -> deep2 -> deep1 -> child)
query II
SELECT d1.grp, SUM(d1.val)
FROM bitslice_deepleaf d1
INNER JOIN bitslice_deep2 d2 ON d1.d2_id = d2.id
INNER JOIN bitslice_deep1 d3 ON d2.d1_id = d3.id
GROUP BY d1.grp
ORDER BY d1.grp
----
0	0
1	15
2	40
3	25
4	60

# Test with full FK chain explicit joins (deepleaf -> deep2 -> deep1 -> child -> pu)
query II
SELECT d1.grp, COUNT(*)
FROM bitslice_deepleaf d1
INNER JOIN bitslice_deep2 d2 ON d1.d2_id = d2.id
INNER JOIN bitslice_deep1 d3 ON d2.d1_id = d3.id
INNER JOIN bitslice_fk_child c ON d3.child_id = c.id
GROUP BY d1.grp
ORDER BY d1.grp
----
0	0
1	5
2	0
3	0
4	5

# Test reverse join order (starting from middle of chain)
query II
SELECT d1.grp, AVG(d1.val)::DECIMAL(5, 2)
FROM bitslice_deep2 d2
INNER JOIN bitslice_deepleaf d1 ON d1.d2_id = d2.id
GROUP BY d1.grp
ORDER BY d1.grp
LIMIT 3
----
0	0.00
1	3.00
2	8.00

# Test with multiple aggregates on joined tables
query III
SELECT d1.grp, SUM(d1.val), MAX(d2.id)
FROM bitslice_deepleaf d1
INNER JOIN bitslice_deep2 d2 ON d1.d2_id = d2.id
INNER JOIN bitslice_deep1 d3 ON d2.d1_id = d3.id
GROUP BY d1.grp
ORDER BY d1.grp
LIMIT 3
----
0	0	0
1	15	0
2	40	2

# Test join with WHERE clause filtering
query II
SELECT d1.grp, SUM(d1.val)
FROM bitslice_deepleaf d1
INNER JOIN bitslice_deep2 d2 ON d1.d2_id = d2.id
WHERE d1.grp > 1
GROUP BY d1.grp
ORDER BY d1.grp
----
2	40
3	25
4	60

# Test with cross-chain join (two different FK paths to same PU)
query II
SELECT l.grp, SUM(l.val + d.val)
FROM bitslice_fk_leaf l
INNER JOIN bitslice_fk_child c ON l.child_id = c.id
INNER JOIN bitslice_fk_side s ON c.pu_id = s.pu_id
INNER JOIN bitslice_deepleaf d ON s.grp2 = d.grp
GROUP BY l.grp
ORDER BY l.grp
LIMIT 3
----
0	0
1	750
2	2000

# Test with aliased columns and expressions
query II
SELECT d1.grp AS group_key, SUM(d1.val * 2) AS doubled_sum
FROM bitslice_deepleaf d1
INNER JOIN bitslice_deep2 d2 ON d1.d2_id = d2.id
GROUP BY d1.grp
ORDER BY d1.grp
LIMIT 3
----
0	0
1	30
2	80

# Test joining leaf with child directly (skipping intermediate tables)
query II
SELECT l.grp, COUNT(DISTINCT c.pu_id)
FROM bitslice_fk_leaf l
INNER JOIN bitslice_fk_child c ON l.child_id = c.id
GROUP BY l.grp
ORDER BY l.grp
----
0	0
1	5
2	0
3	0
4	5

# Test complex join with multiple tables and aggregates
query IIII
SELECT d1.grp, COUNT(*), SUM(d1.val), AVG(c.val)::DECIMAL(5, 2)
FROM bitslice_deepleaf d1
INNER JOIN bitslice_deep2 d2 ON d1.d2_id = d2.id
INNER JOIN bitslice_deep1 d3 ON d2.d1_id = d3.id
INNER JOIN bitslice_fk_child c ON d3.child_id = c.id
GROUP BY d1.grp
ORDER BY d1.grp
LIMIT 2
----
0	0	0	0.00
1	5	15	1.00

# Test with self-referential join pattern (child joins with side on same PU)
query III
SELECT c.grp, COUNT(*), SUM(s.val2)
FROM bitslice_fk_child c
INNER JOIN bitslice_fk_side s ON c.pu_id = s.pu_id
INNER JOIN bitslice_fk_pu p ON c.pu_id = p.id
GROUP BY c.grp
ORDER BY c.grp
LIMIT 3
----
0	0	0
1	25	75
2	0	200

# Test joining in weird order (right to left in FK chain)
query II
SELECT c.grp, SUM(d1.val)
FROM bitslice_fk_child c
INNER JOIN bitslice_deep1 d3 ON d3.child_id = c.id
INNER JOIN bitslice_deep2 d2 ON d2.d1_id = d3.id
INNER JOIN bitslice_deepleaf d1 ON d1.d2_id = d2.id
GROUP BY c.grp
ORDER BY c.grp
----
0	0
1	15
2	40
3	25
4	60

# Test with HAVING clause on joined aggregates
query II
SELECT d1.grp, SUM(d1.val)
FROM bitslice_deepleaf d1
INNER JOIN bitslice_deep2 d2 ON d1.d2_id = d2.id
GROUP BY d1.grp
HAVING SUM(d1.val) > 20
ORDER BY d1.grp
----
2	40
3	25
4	60

# Test multiple joins with mixed table references
query III
SELECT d1.grp, COUNT(d1.id), COUNT(DISTINCT d2.id)
FROM bitslice_deepleaf d1
INNER JOIN bitslice_deep2 d2 ON d1.d2_id = d2.id
INNER JOIN bitslice_deep1 d3 ON d2.d1_id = d3.id
GROUP BY d1.grp
ORDER BY d1.grp
LIMIT 2
----
0	0	0
1	5	5

# Cleanup
statement ok
PRAGMA remove_pac_privacy_unit('bitslice_fk_pu');

statement ok
DROP TABLE bitslice_fk_leaf

statement ok
DROP TABLE bitslice_deepleaf

statement ok
DROP TABLE bitslice_deep2

statement ok
DROP TABLE bitslice_deep1

statement ok
DROP TABLE bitslice_fk_child

statement ok
DROP TABLE bitslice_fk_side

statement ok
DROP TABLE bitslice_fk_pu
